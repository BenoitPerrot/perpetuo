<link rel="import" href="../../bower_components/polymer/polymer.html"/>

<script>
'use strict';

this.Perpetuo = this.Perpetuo || {}
this.Perpetuo.Client = this.Perpetuo.Client || (function () {

  function jsonFetch(url, options) {
    return fetch(url, Object.assign({
      headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
      credentials: 'include'
    }, options || {}));
  }

  function memoize(f) {
    const memoized = () => {
      if (!memoized.hasOwnProperty('__cache')) {
        memoized.__cache = f();
      }
      return memoized.__cache;
    };
    return memoized;
  }

  const fetchAuthorizeURL = memoize(() => jsonFetch('/api/auth/authorize-url').then(_ => _.json()).then(_ => _.url));

  return class Client {
    constructor(host) {
      this.host = host;

      this.hasMoreDeploymentRequests = undefined; // Unknown until first request
    }

    redirectToAuthorizeURL(win) {
      fetchAuthorizeURL().then(url => {
        win.location.replace(`${url}&redirect_uri=${window.location.origin}/identify&state=${window.location.href}`);
      });
    }

    identify(accessToken) {
      return jsonFetch('/api/auth/identify', { method: 'POST', body: JSON.stringify({ token: accessToken }) }).then(_ => {
        if (_.status === 200)
          return _.text();
        throw _.statusText;
      }).then(jwt => {
        window.localStorage.jwt = jwt;
        document.cookie = 'jwt=' + window.localStorage.jwt;
      });
    }

    fetchIdentity() {
      return jsonFetch('/api/auth/identity').then(r => r.json()).then(o => o.name).catch(() => null);
    }

    fetchDeploymentRequest(id) {
      return jsonFetch(`/api/unstable/deployment-requests/${id}`)
        .then(_ => _.json());
    }
    fetchDeploymentRequests(options) {
      options = Object.assign({ where: [], orderBy: [], limit: 20, offset: 0 }, options);
      options.limit = options.limit + 1; // Ask for one more element to know if more are available TODO: remove
      return jsonFetch('/api/unstable/deployment-requests', { method: 'POST', body: JSON.stringify(options) })
        .then(_ => _.json()).then(deploymentRequests => {
          this.hasMoreDeploymentRequests = deploymentRequests.length == options.limit; // TODO: handle in caller
          if (this.hasMoreDeploymentRequests) {
            deploymentRequests.pop();
          }
          return deploymentRequests.map(_ => Object.assign(_, { productType: 'mesos' })) // TODO: have the productType in the backend
        });
    }
    createDeploymentRequest(productName, version, target, comment) {
      return jsonFetch('/api/deployment-requests', { method: 'POST', body: JSON.stringify({
        productName: productName,
        version: version,
        target: target,
        comment: comment
      }) });
    }
    startDeploymentRequest(deploymentRequestId) {
      return jsonFetch(`/api/deployment-requests/${deploymentRequestId}`, { method: 'PUT' });
    }

    fetchProducts() {
      return jsonFetch('/api/products').then(_ => _.json()).then(products => products.map(_ => { return {type: 'mesos', name: _} })); // TODO: have the productType in the backend
    }
    createProduct(productName) {
      return jsonFetch('/api/products', { method: 'POST', body: JSON.stringify({name: productName}) });
    }
    validateProductVersion(productName, version) {
      return jsonFetch(`/api/products/validate-version`, { method: 'POST', body: JSON.stringify({name: productName, version: version}) }).then(_ => _.json());
    }
    suggestProductVersions(productName) {
      return jsonFetch(`/api/products/suggest-versions`, { method: 'POST', body: JSON.stringify({name: productName}) }).then(_ => _.json());
    }
  };
} ());
</script>
